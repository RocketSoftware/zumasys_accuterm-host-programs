SUBROUTINE FTSVRSUB(SESSIONID, MAT PARAMS, MAT CLIENV, FV)
**************************************************************************
*Copyright (c) 1996-2020 Zumasys,Inc. as an unpublished work. All rights *
*reserved. This work is the property of and embodies trade secrets and   *
*confidential information proprietary to Zumasys, Inc.  It may not be    *
*reproduced, copied, used, disclosed, transferred, adapted or modified   *
*without the express written approval of Zumasys, Inc., except as        *
*provided for in the accompanying warranty notice and licensing          *
*agreement.                                                              *
**************************************************************************
*
* MODULE: FTSVRSUB
* AUTHOR: PJS
* VERSION: 8.0.5
* CREATED: 01/01/1996
* UPDATED: 05/30/2020
*
* MAINTENANCE RECORD:
*
* 8.0.5
*  PJS 05/30/2020
*   Added initialization for ERRCD & ERMSG before each call to RCS hook
*   to prevent unsassigned variable error on jBASE.
*
* 8.0.4
*  PJS 05/06/2020
*   Added RCS hooks for FSI functions, used when RCS routine
*   supports version 3 or higher.
*
* 8.0.3
*  PJS 04/02/2020
*   Added RCS hooks for CALL, EXECUTE & CONV, used when RCS routine
*   supports version 3 or higher.
*
* 8.0.2
*  PJS 02/11/2020
*   Added support for MVON# platform (MVON). Changed
*   variable ERRMSG to ERMSG for MVON# compatibility.
*
* 8.0.1
*  PJS 02/06/2020
*   Added ugly hack for non-autoclose SESSIONID. VSCODE RestFS cannot use
*   the auto-close feature because each REST request is a separate connection.
*   So we cannot use auto-close to shut down server mode when the connection
*   object is released. But ServerManager.Connect() only matches the server
*   ID when it has a $ prefix (bug!). So we add a hack, using @ prefix in
*   SESSIONID to use SESSIONID for the server name instead of SVRNAME. Then
*   ServerManager.Connect() will find the matching server name, not ID.
*
* 7.1.3
*  PJS 09/17/2015
*   Modified PARSE.IO.CMD so that it un-quotes the ItemID argument (3) when
*   parsing the command. This will allow ID's with embedded commas or semicolons.
*   In conjunction with this change, atmvsv71.exe (7.1.2015) was also was modified
*   to add quotes if filename or ID has an embedded comma or semicolon.
*
* 7.1.2
*  PJS 03/19/2014
*   Added support for OASYS platform.
*
* 7.1.1
*  PJS 10/30/2012
*   Added ehnanced RCS hook functionality.
*
* 5.3.7
*  PJS 12/20/2007
*   Added support for CACHE platform.
*
* 5.3.6
*  PJS 03/05/2007
*   Fixed typo in UV version (SVRINFO = ...)
*
* 5.3.5
*  PJS 11/08/2006
*   Added support for ON (ONWare MVON) platform.
*
* 5.3.4
*  PJS 07/24/2006
*   Changed NR platform to use @ACCOUNT instead of U50BB. Added
*   support for OI (OpenInsight CTO) platform. Open MD or VOC at
*   beginning of this routine, and pass MD file variable to FTSXT
*   and FTFSI, which commonly need access to this file.
*
* 5.3.3
*  PJS 06/12/2006
*   Call FTCLISVR routine to handle client/server protocol with
*   enhanced error detection & recovery.
*
* 5.3.2
*  PJS 05/08/2006
*   Added new, stricter file locking, since multiple clients may try
*   to read the same item (or the same client tries to read multiple
*   copies). Traditional item locks handle locking at the process
*   level, and a new local lock table handles locking at the client
*   level. Check local item lock table in READU function, and return
*   "locked" status if item has already been locked. Add locked items
*   to the local lock table in READU, and clear in WRITE, DELETE or
*   RELEASE functions. This is consistent with how files are locked
*   in the Windows file system, but might cause problems if a client
*   program expects to be able to READU the same item multiple times,
*   especially if using READVU. However, it solves the problem of having
*   multiple copies of the same item open in the wED Editor or GUI
*   Designer, where the user could be confused about which copy to save.
*   With the local lock table, one of the copies would be marked as
*   "read only" in wED, GED, etc.
*
*   NOTE: the new "strict locking" can be disabled by editing the KMTCFG
*   item in the ACCUTERMCTRL file and changing attribute 58 to 1.
*
* 5.3.1
*  PJS 04/12/2006
*   Check for "optional final ack" feature ('1' in CLI.CAPAS string)
*   and if found, do not ack the final packet of a message. This should
*   reduce the incidence of "TCP delayed ack" slowing down throughput.
*
* 5.2.3
*  PJS 08/16/2005
*   Changed U50BB to @ACCOUNT, @USER, @PIB for PICK (D3) platform
*   type to account for unpredictable format of U50BB result:
*   "WHO (A" vs. "WHO (C".
*
* 5.2.2
*  PJS 01/21/2005
*   Added buffering logic to receive large messages more efficiently.
*
* 5.2.1
*  PJS 01/06/2005
*   Added hooks for integrating a revision control system (PRC at
*   this time, but should be adaptable to other RCS). This involved
*   picking up the client application name (atwed32, etc.) as a 10th
*   field in the READ/WRITE/ADD/READNEXT/UNLOCK command string, so
*   it can be passed to the RCS to identify the application accessing
*   the file system. Hooks have been added to the READ, WRITE, DELETE
*   and RELEASE functions to call the RCS interface routine at the
*   appropriate time. Except for READ, the RCS routine can change the
*   file name. The RCS routine can set the ERRCD argument to any non-
*   zero value to cancel the action and return an error to the client.
*
* 5.0.9
*  PJS 09/29/2004
*   Changed max string length from 9999999 to 999999999
*
* 5.0.8
*  PJS 03/05/2004
*   Added new NR (Northgate Reality 9+) platform type, same as
*   old MD platform.
*
* 5.0.7
*  PJS 01/14/2004
*   Fixed UniData version by adding a blank before the semicolon
*   after the ON ERROR clause.
*
* 5.0.6
*  PJS 10/24/2003
*   Integrated QM platform specific code per mods from Martin
*   Phillips.
*
* 5.0.5
*  PJS 09/11/2003
*   Modified PRINT expressions for UniVerse because concatenated
*   expressions are sent in separate packets in NT version of
*   UniVerse causing TCP "delayed ack" performance issues.
*
* 5.0.4
*  PJS 09/10/2003
*   Added ON ERROR and ELSE clauses to WRITE command for PICK (D3),
*   UV, UD and JB platforms. Other platforms not yet tested for syntax.
*
* 5.0.3
*  PJS 10/08/2002
*   Added new ULTX (ancient Ultimate) platform type which uses
*   old EXECUTE syntax (YUK!)
*
* 5.0.2
*  PJS 09/15/2002
*   Moved PROMPT statement immediately before INPUT statement since
*   some subroutines may reset PROMPT. Removed ECHO ON from inside
*   of LOOP, since the ECHO OFF / ECHO ON sequence is VERY SLOW on
*   D3/NT. This fix greatly improves speed of wED editor on D3/NT!
*   Added support for ERR: responses to display fatal errors. Added
*   extra info in the startup message so emulator does not need to
*   query for user name, account, port, rights, etc.
*
* 5.0.1
*  PJS 02/17/2002
*   Added new element to CLIENV() array for FTBP library version number.
*
* 4.1.2
*  PJS 09/12/2001
*   Added SESSIONID variable to argument list. When SESSIONID is
*   not null, it is used as a private session ID. If the ID has a
*   leading dollar sign, the server session will "autoclose".
*
* 4.1.1
*  PJS 06/04/2001
*   Added FSI command to retrieve host file system information.
*   Fixed file variable cache to actually work.
*   Added FV to argument list.
*
* 4.0.5
*  PJS 05/11/2001
*   Added new platform typeS: SEQ (Sequoia/mvEnterprise) & VIS (UniVision)
*
* 4.0.4
*  PJS 12/14/2000
*   Added new platform type: MVBASE
*
* 4.0.3
*  PJS 11/24/2000
*   Added new platform type: AP
*
* 4.0.2
*  PJS 11/03/2000
*   Added new platform type: MD
*
* 4.0.1
*  PJS 09/25/2000
*   CLEANUP FOR ACCUTERM 2000 RELEASE
*   ADDED MAT CLIENV ARGUMENT - CONTAINS ACCUTERM INFORMATION
*   ADDED NEW STREAMING PROTOCOL TO IMPROVE THRUPUT
*   CALLS FTSXT SUBROUTINE DIRECTLY SO CLIENV CAN BE PASSED
*
**************************************************************************
**************************************************************************
*
* ACCUTERM PICK SERVER
*
**************************************************************************
**************************************************************************
*
EQU REL TO '1.6'
EQU AM TO CHAR(254)
EQU ESC TO CHAR(27), STX TO CHAR(2), CR TO CHAR(13)
*
DIM PARAMS(30)
EQU MAX.POS.PARAM TO PARAMS(1)
EQU MCP.FLG.PARAM TO PARAMS(10)
EQU EXTRA.AM.PARAM TO PARAMS(20)
EQU SVRNAME TO PARAMS(26)
EQU READ.OK TO PARAMS(27)
EQU WRITE.OK TO PARAMS(28)
EQU CONV.OK TO PARAMS(29)
EQU EXEC.OK TO PARAMS(30)
*
DIM CLIENV(10)
EQU CLI.PLATFORM TO CLIENV(1)
EQU CLI.PRODUCT TO CLIENV(2)
EQU CLI.RELEASE TO CLIENV(3)
EQU CLI.CAPAS TO CLIENV(4)
EQU CLI.SVCS TO CLIENV(5)
EQU CLI.SERIAL TO CLIENV(6)
EQU CLI.LICENSE TO CLIENV(7)
EQU CLI.USER TO CLIENV(8)
EQU CLI.VERSION TO CLIENV(9)
EQU CLI.CONFIG TO CLIENV(10)
*
DIM IO.ARRAY(10)
EQU IO.CMD TO IO.ARRAY(1); * THE READ/WRITE COMMAND
EQU IO.FNAME TO IO.ARRAY(2); * FILE NAME
EQU IO.RNAME TO IO.ARRAY(3); * RECORD NAME
EQU IO.ATTR TO IO.ARRAY(4); * ATTRIBUTE TO READ
EQU IO.VAR TO IO.ARRAY(5); * VALUE TO READ
EQU IO.SVAR TO IO.ARRAY(6); * SUBVALUE TO READ
EQU IO.FIELD TO IO.ARRAY(7); * FIELD TO READ
EQU IO.DELIM TO IO.ARRAY(8); * FIELD DELIMITER
EQU IO.MASK TO IO.ARRAY(9); * OUTPUT MASK
EQU IO.CLIENT TO IO.ARRAY(10); * CLIENT APPLICATION NAME (RCS USE)
*
DIM OPEN.FILES(200)
*
**************************************************************************
*
*SERVER COMMANDS:
*
*EXECUTE,CAPTURE;COMMAND:AM:DATA ...
*READ,FILENAME,ID,ATTR,VAL,SVAL
*WRITE,FILENAME,ID,ATTR,VAL,SVAL;DATA
*ADD,FILENAME,ID;DATA
*READNEXT,FILENAME,ATTR,VAL,SVAL
*CALL,SUBNAME,FUNC;DATA
*CONV,I/O;CODE:AM:DATA
*FSI,FUNC;DATA
*EXIT
*
**************************************************************************
*
OPEN 'MD' TO MD ELSE
 OPEN 'VOC' TO MD ELSE
  PRINT 'Unable to open MD (or VOC) file!'
  RETURN
 END
END
*
MAT IO.ARRAY=''
MAT OPEN.FILES=''
LOCAL.LOCK.TABLE=''
* UGLY HACK FOR NON-AUTOCLOSE SERVER ID (SESSION ID MATCHING IN SERVERMANAGER ONLY WORKS WITH $ PREFIX!)
IF SESSIONID[1,1] = '@' THEN
 SVRNAME = SESSIONID
 SESSIONID = ''
END
*
IF INDEX(CLI.SVCS,'0',1)>0 THEN
 * NEW AUTOMATION SERVER ACCEPTS COMPLETE SERVER INFO
 WHO = OCONV('','U50BB');*#DEFAULT#*
 ACCT = FIELD(WHO,' ',3);*#DEFAULT#*
 IF ACCT = '' THEN ACCT = FIELD(WHO,' ',2);*#DEFAULT#*
 SVRINFO = SESSIONID:'|':SVRNAME:'|':ACCT:'|':FIELD(WHO,' ',2):'|':FIELD(WHO,' ',1):'|':'MD';*#DEFAULT#*
*#ADDS#* WHO = OCONV('','U50BB')
*#ADDS#* ACCT = FIELD(WHO,' ',3)
*#ADDS#* IF ACCT = '' THEN ACCT = FIELD(WHO,' ',2)
*#ADDS#* SVRINFO = SESSIONID:'|':SVRNAME:'|':ACCT:'|':FIELD(WHO,' ',2):'|':FIELD(WHO,' ',1):'|':'MD'
*#AP#* WHO = OCONV('','U50BB')
*#AP#* ACCT = FIELD(WHO,' ',3)
*#AP#* IF ACCT = '' THEN ACCT = FIELD(WHO,' ',2)
*#AP#* SVRINFO = SESSIONID:'|':SVRNAME:'|':ACCT:'|':FIELD(WHO,' ',2):'|':FIELD(WHO,' ',1):'|':'MD'
*#CACHE#* SVRINFO = SESSIONID:'|':SVRNAME:'|':@WHO:'|':@LOGNAME:'|':@USERNO:'|':'VOC'
*#ENH#* WHO = OCONV('','U50BB')
*#ENH#* ACCT = FIELD(WHO,' ',3)
*#ENH#* IF ACCT = '' THEN ACCT = FIELD(WHO,' ',2)
*#ENH#* SVRINFO = SESSIONID:'|':SVRNAME:'|':ACCT:'|':FIELD(WHO,' ',2):'|':FIELD(WHO,' ',1):'|':'MD'
*#JB#* SVRINFO = SESSIONID:'|':SVRNAME:'|':@WHO:'|':@LOGNAME:'|':@USERNO:'|':'MD'
*#MD#* WHO = OCONV('','U50BB')
*#MD#* ACCT = FIELD(WHO,' ',3)
*#MD#* IF ACCT = '' THEN ACCT = FIELD(WHO,' ',2)
*#MD#* SVRINFO = SESSIONID:'|':SVRNAME:'|':ACCT:'|':FIELD(WHO,' ',2):'|':FIELD(WHO,' ',1):'|':'MD'
*#MVBASE#* WHO = OCONV('','U50BB')
*#MVBASE#* ACCT = FIELD(WHO,' ',3)
*#MVBASE#* IF ACCT = '' THEN ACCT = FIELD(WHO,' ',2)
*#MVBASE#* SVRINFO = SESSIONID:'|':SVRNAME:'|':ACCT:'|':FIELD(WHO,' ',2):'|':FIELD(WHO,' ',1):'|':'MD'
*#MVON#* SVRINFO = SESSIONID:'|':SVRNAME:'|':@WHO:'|':@LOGNAME:'|':@USERNO:'|':'VOC'
*#NR#* SVRINFO = SESSIONID:'|':SVRNAME:'|':@ACCOUNT:'|':@LOGNAME:'|':@USERNO:'|':'MD'
*#OAS#* SVRINFO = SESSIONID:'|':SVRNAME:'|':@WHO:'|':@LOGNAME:'|':@USERNO:'|':'VOC'
*#OI#* SVRINFO = SESSIONID:'|':SVRNAME:'|':@APPID<1>:'|':@USERNAME:'|':SYSTEM(18):'|':'MD'
*#ON#* SVRINFO = SESSIONID:'|':SVRNAME:'|':@WHO:'|':@LOGNAME:'|':@USERNO:'|':'VOC'
*#PICK#* SVRINFO = SESSIONID:'|':SVRNAME:'|':@ACCOUNT:'|':@USER:'|':@PIB:'|':'MD'
*#QM#* SVRINFO = SESSIONID:'|':SVRNAME:'|':@WHO:'|':@LOGNAME:'|':@USERNO:'|':'VOC'
*#R83#* WHO = OCONV('','U50BB')
*#R83#* ACCT = FIELD(WHO,' ',3)
*#R83#* IF ACCT = '' THEN ACCT = FIELD(WHO,' ',2)
*#R83#* SVRINFO = SESSIONID:'|':SVRNAME:'|':ACCT:'|':FIELD(WHO,' ',2):'|':FIELD(WHO,' ',1):'|':'MD'
*#SEQ#* WHO = OCONV('','U50BB')
*#SEQ#* ACCT = FIELD(WHO,' ',3)
*#SEQ#* IF ACCT = '' THEN ACCT = FIELD(WHO,' ',2)
*#SEQ#* SVRINFO = SESSIONID:'|':SVRNAME:'|':ACCT:'|':FIELD(WHO,' ',2):'|':FIELD(WHO,' ',1):'|':'MD'
*#UD#* SVRINFO = SESSIONID:'|':SVRNAME:'|':@WHO:'|':@LOGNAME:'|':@UDTNO:'|':'VOC'
*#ULT#* WHO = OCONV('','U50BB')
*#ULT#* ACCT = FIELD(WHO,' ',3)
*#ULT#* IF ACCT = '' THEN ACCT = FIELD(WHO,' ',2)
*#ULT#* SVRINFO = SESSIONID:'|':SVRNAME:'|':ACCT:'|':FIELD(WHO,' ',2):'|':FIELD(WHO,' ',1):'|':'MD'
*#ULTX#* WHO = OCONV('','U50BB')
*#ULTX#* ACCT = FIELD(WHO,' ',3)
*#ULTX#* IF ACCT = '' THEN ACCT = FIELD(WHO,' ',2)
*#ULTX#* SVRINFO = SESSIONID:'|':SVRNAME:'|':ACCT:'|':FIELD(WHO,' ',2):'|':FIELD(WHO,' ',1):'|':'MD'
*#UV#* SVRINFO = SESSIONID:'|':SVRNAME:'|':@WHO:'|':@LOGNAME:'|':@USERNO:'|':'VOC'
*#VIS#* WHO = OCONV('','U50BB')
*#VIS#* ACCT = FIELD(WHO,' ',3)
*#VIS#* IF ACCT = '' THEN ACCT = FIELD(WHO,' ',2)
*#VIS#* SVRINFO = SESSIONID:'|':SVRNAME:'|':ACCT:'|':FIELD(WHO,' ',2):'|':FIELD(WHO,' ',1):'|':'MD'
 SVRINFO = SVRINFO:'|':FIELD(CLI.VERSION,'.',1):'.':FIELD(CLI.VERSION,'.',2)
 SVRINFO = SVRINFO:'|':NOT(READ.OK):'.':NOT(WRITE.OK):'.':NOT(CONV.OK):'.':NOT(EXEC.OK)  
END ELSE
 * OLD SERVER ONLY ACCEPTS ID OR NAME
 IF SESSIONID='' THEN
  SVRINFO = SVRNAME
 END ELSE
  SVRINFO = SESSIONID
 END
END
*
A.REC=''
ERR=0
ID=''
KEYWORD=''
LAST.CHAR=''
NEW.CMD=''
PASS.DATA=''
SKIP.PARSE.IO=0
SKIP.TO.CHECK=0
*
* Get optional RCS subroutine name from attr 2 of item 'RCS' in ACCUTERMCTRL file
* Updated for release 7.1: RCS hook has new interface version (2), which supports
* a new action code to indicate when a record is locked. When initializing the
* RCS hook subroutine (action=0), perform interface version negotiation and select
* lowest supported version.
RCS.VER=0 ;* assume no RCS hook
READV RCS.SUB FROM FV,'RCS',2 THEN
 IF RCS.SUB NE '' THEN
  RCS.VER=1 ;* assume original version
  RCS.DATA='VER':AM:2
  ERRCD=0; ERMSG=''
  CALL @RCS.SUB(0,'','',RCS.DATA,'',ERRCD,ERMSG) ;*THIS WILL CAUSE A RUNTIME ERROR IF RCS SPECIFIED BUT NOT FOUND!
  IF ERRCD THEN
   PRINT ERMSG
   RETURN
  END
  IF RCS.DATA<3> >= 3 THEN RCS.VER=3 ;* hook supports interface version 3
 END
END ELSE
 RCS.VER=0
END
*
* Select client/server protocol based on capabilities of emulator & host config
IF INDEX(CLI.CAPAS,'P',1) > 0 THEN
 PROTOCOL = 1 + (2 * (INDEX(CLI.CAPAS,'R',1)>0) * NOT(CLI.CONFIG<1,55>));* 1=packetized, 3=streaming (2=reserved)
END ELSE
 PROTOCOL = 0;* 0=basic
END
STRICT.LOCKING = NOT(CLI.CONFIG<1,58>)
*
ST.COM=''
IF PROTOCOL < 2 THEN
 ST.SEQ = ESC:STX:'d':SVRINFO:CR
END ELSE
 ST.SEQ = ESC:STX:'f':SVRINFO:CR
END
RTN.SEQ = ESC:STX:'s'; * RETURN RESULT TO CLIENT
**REQ.SEQ = ESC:STX:'o'; * READY FOR INPUT
*
THE.CMD=''
THE.REC=''
THE.SEQ=''
ULOCK=0
*
PRINT ST.SEQ: ;* Start server mode
*
ERRCNT = 0
SKIP.SEND = 1
DONE = 0
LOOP UNTIL DONE OR ERRCNT > 2 DO
 * get next request from client
** IF PROTOCOL < 2 AND NOT(NOFINALACK) THEN
**  PRINT REQ.SEQ:;* inform client we're ready to accept a request
** END
 CALL FTCLISVR('0',SKIP.SEND,MESSAGES,CMD,1,ERRCD,ERMSG,MAT PARAMS,MAT CLIENV)
 IF ERRCD THEN
  ERRCNT = ERRCNT + 1;* count sequential errors to detect error loop
  IF ERRCD = -100 THEN
   DONE = 1;* user abort
  END ELSE
   * send protocol errors back to client
   MESSAGES='OK;':ERRCD:';':ERMSG:';ERROR'
  END
 END ELSE
  * process the request
  ERRCNT = 0
  GOSUB PARSE.CMD
  GOSUB PROCESS.CMD
 END
 SKIP.SEND = 0
REPEAT
PRINT '':(RTN.SEQ:'EX':CR):;* terminate remote server process
IF ERRCNT > 2 THEN
 PRINT 'Error loop detected; server terminated.'
END
RETURN
!
*
PROCESS.CMD: *
*
IF KEYWORD='EXIT' THEN DONE = 1; RETURN
*
MESSAGES='OK;2;COMMAND NOT AVAILABLE;ERROR'
*
BEGIN CASE
 CASE KEYWORD='EXECUTE'
  IF EXEC.OK THEN GOSUB DO.EXECUTE
 CASE KEYWORD='READNEXT'
  IF READ.OK THEN GOSUB DO.READNEXT
 CASE KEYWORD='READ'
  IF READ.OK THEN GOSUB DO.READ
 CASE KEYWORD='WRITE'
  IF WRITE.OK THEN GOSUB DO.WRITE
 CASE KEYWORD='ADD'
  IF WRITE.OK THEN GOSUB DO.WRITE
 CASE KEYWORD='DELETE'
  IF WRITE.OK THEN GOSUB DO.DELETE
 CASE KEYWORD='RELEASE'
  IF READ.OK THEN GOSUB DO.RELEASE
 CASE KEYWORD='CALL'
  IF EXEC.OK THEN GOSUB DO.CALL
 CASE KEYWORD='CONV'
  IF CONV.OK THEN GOSUB DO.CONV
 CASE KEYWORD='FSI'
  GOSUB DO.FSI
 CASE KEYWORD='ERR'
  PRINT
  PRINT 'AccuTerm encountered the following fatal error:'
  PRINT THE.DATA
  PRINT
  DONE = 1
  RETURN
 CASE 1
  ERR=1
  MESSAGES='OK;1;WRONG FORMAT;ERROR'
END CASE
*
IF NOT(ERR) THEN
 MESSAGES="OK;0;;":MESSAGES;* add message header to result
END
*
RETURN
*
!
*
DO.READ: *
*
*READ,FNAME,ID{,ATTR{,VAL{,SUBVAL{,,,,CLIENT}}}}
*
IF NOT(SKIP.PARSE.IO) THEN
 GOSUB PARSE.IO.CMD
 IF IO.FNAME='' THEN
  ERR=1
  MESSAGES='OK;200;File name missing;ERROR'
  RETURN
 END
 IF IO.RNAME='' THEN
  ERR=1
  MESSAGES='OK;203;Item ID missing;ERROR'
  RETURN
 END
END
IF ULOCK THEN
 * LOCK THE RECORD BEFORE READ
 GOSUB INTERNAL.LOCK
 IF ERR THEN RETURN
END
MESSAGES=''
SAVE.FNAME=IO.FNAME
SAVE.RNAME=IO.RNAME
TMP.FNAME=IO.FNAME
TMP.RNAME=IO.RNAME
*BEGIN RCS BEFORE READ HOOK
IF RCS.VER>=2 THEN
 ERRCD=0; ERMSG=''
 CALL @RCS.SUB(6,TMP.FNAME,TMP.RNAME,WORK,IO.CLIENT,ERRCD,ERMSG) ;* CALL RCS BEFORE READING RECORD
 IF ERRCD=-1 THEN
  * RCS HANDLED THE READ
  GOTO FINISH.READ ;* EXTRACT SPECIFIED ATTR/VAL/SUBVAL & RETURN RESULT
 END
 IF ERRCD THEN
  IF ULOCK THEN 
   * IF RCS FAILS THE READ, RELEASE THE LOCK
   SAVE.ERRCD=ERRCD
   SAVE.ERMSG=ERMSG
   GOSUB INTERNAL.RELEASE
   ERRCD=SAVE.ERRCD
   ERMSG=SAVE.ERMSG
  END
  ERR=1 ;* RCS CANCELLED READ - RETURN ERROR TO CLIENT
  MESSAGES='OK;':ERRCD:';':ERMSG:';ERROR'
  RETURN
 END
 IO.FNAME=TMP.FNAME
 IO.RNAME=TMP.RNAME
 IF IO.RNAME='' THEN
  ERR=1
  MESSAGES='OK;203;Item ID missing;ERROR'
  RETURN
 END
END
*END RCS BEFORE READ HOOK
GOSUB OPEN.FILE
IF ERR THEN RETURN
READ WORK FROM FLV,IO.RNAME ELSE
 ERR=1
 MESSAGES='OK;202;Unable to read record ':IO.FNAME:' ':IO.RNAME:';ERROR'
 RETURN
END
*BEGIN RCS AFTER READ HOOK
IF RCS.VER THEN
 ERRCD=0; ERMSG=''
 CALL @RCS.SUB(1,TMP.FNAME,TMP.RNAME,WORK,IO.CLIENT,ERRCD,ERMSG) ;* CALL RCS AFTER READING RECORD
 IF ERRCD=-1 THEN ERRCD=0
 IF ERRCD THEN
  * IF RCS FAILS THE READ, RELEASE THE LOCK
  IF ULOCK THEN
   SAVE.ERRCD=ERRCD
   SAVE.ERMSG=ERMSG
   GOSUB INTERNAL.RELEASE
   ERRCD=SAVE.ERRCD
   ERMSG=SAVE.ERMSG
  END
  ERR=1 ;* RCS CANCELLED READ - RETURN ERROR TO CLIENT
  MESSAGES='OK;':ERRCD:';':ERMSG:';ERROR'
  RETURN
 END
END
*END RCS AFTER READ HOOK
FINISH.READ: *
MESSAGES=WORK
IF NOT(NUM(IO.ATTR)) OR IO.ATTR='' OR IO.ATTR=0 THEN
 SKIP.TO.CHECK=1
END ELSE
 SKIP.TO.CHECK=0
END
IF NOT(SKIP.TO.CHECK) THEN
 MESSAGES=MESSAGES<IO.ATTR>
 IF NOT(NUM(IO.VAR)) OR IO.VAR='' THEN SKIP.TO.CHECK=1
 IF NOT(SKIP.TO.CHECK) THEN
  MESSAGES=MESSAGES<1,IO.VAR>
  IF NOT(NUM(IO.SVAR)) OR IO.SVAR='' THEN SKIP.TO.CHECK=1
  IF NOT(SKIP.TO.CHECK) THEN
   MESSAGES=MESSAGES<1,1,IO.SVAR>
  END
 END
END
RETURN
!
*
DO.WRITE: *
*
*WRITE,FNAME,ID{,ATTR{,VAL{,SUBVAL{,,,,CLIENT}}}};DATA
*
GOSUB PARSE.IO.CMD
IF IO.FNAME='' THEN
 ERR=1
 MESSAGES='OK;200;File name missing;ERROR'
 RETURN
END
IF IO.RNAME='' THEN
 ERR=1
 MESSAGES='OK;203;Item ID missing;ERROR'
 RETURN
END
A.REC=THE.DATA
GOSUB OPEN.FILE
IF ERR THEN RETURN
IF NOT(NUM(IO.ATTR)) OR IO.ATTR='' THEN IO.ATTR=0
IF IO.ATTR=0 AND IO.CMD[1,1]#'W' THEN
 READV WORK FROM FLV,IO.RNAME,1 THEN
  * IF COMMAND IS ADD, DONT ALLOW OVERWRITING ENTIRE EXISTING ITEM
  ERR=1
  MESSAGES='OK;223;':IO.FNAME:' ':IO.RNAME:' exists on file;ERROR'
  RETURN
 END
END
IF IO.ATTR <> 0 THEN
 * IN CASE OF SPECIFIED ATTR/VAL/SUBVAL, WE NEED TO READ EXISTING
 * ITEM BEFORE UPDATE (WHICH INCLUDES THE RCS BEFORE UPDATE HOOK)
 READ WORK FROM FLV,IO.RNAME THEN ITEM.EXISTS=1 ELSE WORK=''
 IF NOT(NUM(IO.VAR)) OR IO.VAR='' THEN IO.VAR=0
 IF NOT(NUM(IO.SVAR)) OR IO.SVAR='' THEN IO.SVAR=0
 BEGIN CASE
  CASE IO.ATTR AND IO.VAR AND IO.SVAR
   WORK<IO.ATTR,IO.VAR,IO.SVAR>=A.REC<1,1,1>
  CASE IO.ATTR AND IO.VAR
   WORK<IO.ATTR,IO.VAR>=A.REC<1,1>
  CASE IO.ATTR
   WORK<IO.ATTR>=A.REC<1>
  CASE 1
   WORK=A.REC
   IF EXTRA.AM.PARAM THEN
    IF WORK[LEN(WORK),1] EQ AM THEN WORK=WORK:AM
   END
 END CASE
END ELSE
 WORK=A.REC
 IF EXTRA.AM.PARAM THEN
  IF WORK[LEN(WORK),1] EQ AM THEN WORK=WORK:AM
 END
END
SAVE.FNAME=IO.FNAME
SAVE.RNAME=IO.RNAME
TMP.FNAME=IO.FNAME
TMP.RNAME=IO.RNAME
*BEGIN RCS BEFORE UPDATE HOOK
IF RCS.VER THEN
 ERRCD=0; ERMSG=''
 CALL @RCS.SUB(2,TMP.FNAME,TMP.RNAME,WORK,IO.CLIENT,ERRCD,ERMSG) ;* CALL RCS BEFORE UPDATING RECORD
 IF ERRCD=-1 THEN
  * RCS HANDLED THE UPDATE
  ERR=1 ;* NOT REALLY AN ERROR, JUST A FLAG INDICATING THAT MESSAGES ALREADY HAS ITS HEADER
  MESSAGES='OK;0;Record written;'
  RETURN
 END  
 IF ERRCD THEN
  ERR=1 ;* RCS CANCELLED UPDATE - RETURN ERROR TO CLIENT
  MESSAGES='OK;':ERRCD:';':ERMSG:';ERROR'
  RETURN
 END
 IO.FNAME=TMP.FNAME
 IO.RNAME=TMP.RNAME
 IF SAVE.FNAME NE IO.FNAME THEN
  * RCS CHANGED UPDATE FILE NAME
  GOSUB OPEN.FILE
  IF ERR THEN RETURN
 END
 IF IO.RNAME='' THEN
  ERR=1
  MESSAGES='OK;203;Item ID missing;ERROR'
  RETURN
 END
END
*END RCS BEFORE UPDATE HOOK
WRITEU WORK ON FLV,IO.RNAME;*#DEFAULT#*
*#ADDS#*WRITEU WORK ON FLV,IO.RNAME
*#AP#*WRITEU WORK ON FLV,IO.RNAME
*#CACHE#*WRITEU WORK ON FLV,IO.RNAME ON ERROR
*#CACHE#* MESSAGES='OK;261;':IO.FNAME:' ':IO.RNAME:' update failed;ERROR'
*#CACHE#* ERR=1
*#CACHE#* RETURN
*#CACHE#*END
*#ENH#*WRITEU WORK ON FLV,IO.RNAME
*#JB#*WRITEU WORK ON FLV,IO.RNAME ON ERROR
*#JB#* MESSAGES='OK;261;':IO.FNAME:' ':IO.RNAME:' update failed;ERROR'
*#JB#* ERR=1
*#JB#* RETURN
*#JB#*END
*#MD#*WRITEU WORK ON FLV,IO.RNAME
*#MVBASE#*WRITEU WORK ON FLV,IO.RNAME
*#MVON#*WRITEU WORK ON FLV,IO.RNAME ON ERROR
*#MVON#* MESSAGES='OK;261;':IO.FNAME:' ':IO.RNAME:' update failed;ERROR'
*#MVON#* ERR=1
*#MVON#* RETURN
*#MVON#*END ELSE
*#MVON#* MESSAGES='OK;261;':IO.FNAME:' ':IO.RNAME:' update failed;ERROR'
*#MVON#* ERR=1
*#MVON#* RETURN
*#MVON#*END
*#NR#*WRITEU WORK ON FLV,IO.RNAME
*#OAS#*WRITEU WORK ON FLV,IO.RNAME ON ERROR ;*
*#OAS#* MESSAGES='OK;261;':IO.FNAME:' ':IO.RNAME:' update failed;ERROR'
*#OAS#* ERR=1
*#OAS#* RETURN
*#OAS#*END
*#OI#*WRITEU WORK ON FLV,IO.RNAME ELSE
*#OI#* MESSAGES='OK;261;':IO.FNAME:' ':IO.RNAME:' update failed;ERROR'
*#OI#* ERR=1
*#OI#* RETURN
*#OI#*END
*#ON#*WRITEU WORK ON FLV,IO.RNAME ON ERROR
*#ON#* MESSAGES='OK;261;':IO.FNAME:' ':IO.RNAME:' update failed;ERROR'
*#ON#* ERR=1
*#ON#* RETURN
*#ON#*END
*#PICK#*WRITEU WORK ON FLV,IO.RNAME ON ERROR
*#PICK#* MESSAGES='OK;261;':IO.FNAME:' ':IO.RNAME:' update failed;ERROR'
*#PICK#* ERR=1
*#PICK#* RETURN
*#PICK#*END
*#QM#*WRITEU WORK ON FLV,IO.RNAME ON ERROR
*#QM#* MESSAGES='OK;261;':IO.FNAME:' ':IO.RNAME:' update failed;ERROR'
*#QM#* ERR=1
*#QM#* RETURN
*#QM#*END
*#R83#*WRITEU WORK ON FLV,IO.RNAME
*#SEQ#*WRITEU WORK ON FLV,IO.RNAME
*#UD#*WRITEU WORK ON FLV,IO.RNAME ON ERROR ;*
*#UD#* MESSAGES='OK;261;':IO.FNAME:' ':IO.RNAME:' update failed;ERROR'
*#UD#* ERR=1
*#UD#* RETURN
*#UD#*END
*#ULT#*WRITEU WORK ON FLV,IO.RNAME
*#ULTX#*WRITEU WORK ON FLV,IO.RNAME
*#UV#*WRITEU WORK ON FLV,IO.RNAME ON ERROR
*#UV#* MESSAGES='OK;261;':IO.FNAME:' ':IO.RNAME:' update failed;ERROR'
*#UV#* ERR=1
*#UV#* RETURN
*#UV#*END ELSE
*#UV#* MESSAGES='OK;261;':IO.FNAME:' ':IO.RNAME:' update failed;ERROR'
*#UV#* ERR=1
*#UV#* RETURN
*#UV#*END
*#VIS#*WRITEU WORK ON FLV,IO.RNAME
*BEGIN RCS AFTER UPDATE HOOK
IF RCS.VER>=2 THEN
 ERRCD=0; ERMSG=''
 CALL @RCS.SUB(7,TMP.FNAME,TMP.RNAME,WORK,IO.CLIENT,ERRCD,ERMSG) ;* CALL RCS AFTER UPDATING RECORD
 IF ERRCD=-1 THEN ERRCD=0
 IF ERRCD THEN
  ERR=1 ;* RCS CANCELLED UPDATE - RETURN ERROR TO CLIENT
  MESSAGES='OK;':ERRCD:';':ERMSG:';ERROR'
  RETURN
 END
END
*END RCS AFTER UPDATE HOOK
IF NOT(ULOCK) THEN GOSUB INTERNAL.RELEASE
IF NOT(ERR) THEN MESSAGES='OK;0;Record written;'
ERR=1 ;* NOT REALLY AN ERROR, JUST A FLAG INDICATING THAT MESSAGES ALREADY HAS ITS HEADER
RETURN
!
*
DO.DELETE: *
*
*DELETE,FNAME,ID{,,,,,,,CLIENT}
*
*NOTE: DELETE WILL FAIL IF THE RECORD IS LOCKED!
*
*TODO: CALL FSI TO GET ATTRIBUTE & FAIL IF FOLDER OR READ-ONLY
GOSUB PARSE.IO.CMD
IF IO.FNAME='' THEN
 ERR=1
 MESSAGES='OK;200;File name missing;ERROR'
 RETURN
END
IF IO.RNAME='' THEN
 ERR=1
 MESSAGES='OK;203;Item ID missing;ERROR'
 RETURN
END
SAVE.FNAME=IO.FNAME
SAVE.RNAME=IO.RNAME
TMP.FNAME=IO.FNAME
TMP.RNAME=IO.RNAME
*BEGIN RCS BEFORE DELETE HOOK
IF RCS.VER THEN
 ERRCD=0; ERMSG=''
 CALL @RCS.SUB(3,TMP.FNAME,TMP.RNAME,'',IO.CLIENT,ERRCD,ERMSG) ;* CALL RCS BEFORE DELETING RECORD
 IF ERRCD=-1 THEN
  * RCS HANDLED THE DELETION
  ERR=1 ;* NOT REALLY AN ERROR, JUST A FLAG INDICATING THAT MESSAGES ALREADY HAS ITS HEADER
  MESSAGES='OK;0;Record deleted;'
  RETURN
 END
 IF ERRCD THEN
  ERR=1 ;* RCS CANCELLED DELETE - RETURN ERROR TO CLIENT
  MESSAGES='OK;':ERRCD:';':ERMSG:';ERROR'
  RETURN
 END
 * RCS MAY HAVE CHANGED THE FILE NAME / ITEM ID
 IO.FNAME=TMP.FNAME
 IO.RNAME=TMP.RNAME
END
*END RCS BEFORE DELETE HOOK
GOSUB OPEN.FILE
IF ERR THEN RETURN
* CHECK IF RECORD IS LOCKED BEFORE DELETING
IO.FNAME=SAVE.FNAME
IO.RNAME=SAVE.RNAME
GOSUB TEST.LOCAL.LOCK
IF LOCAL.LOCKED THEN
 * RECORD IS LOCKED
 ERR=1
 MESSAGES='OK;235;':IO.FNAME:' ':IO.RNAME:' locked;ERROR'
 RETURN
END
READU WORK FROM FLV,TMP.RNAME LOCKED
 * RECORD IS LOCKED
 ERR=1
 MESSAGES='OK;235;':TMP.FNAME:' ':TMP.RNAME:' locked;ERROR'
 RETURN
END ELSE
END
WORK=''
DELETE FLV,TMP.RNAME ;* THIS RELEASES THE READU LOCK SET ABOVE
*BEGIN RCS AFTER DELETE HOOK
IF RCS.VER>=2 THEN
 ERRCD=0; ERMSG=''
 CALL @RCS.SUB(8,TMP.FNAME,TMP.RNAME,'',IO.CLIENT,ERRCD,ERMSG) ;* CALL RCS AFTER DELETING RECORD
 IF ERRCD=-1 THEN ERRCD=0
 IF ERRCD THEN
  ERR=1 ;* RCS CANCELLED DELETE - RETURN ERROR TO CLIENT
  MESSAGES='OK;':ERRCD:';':ERMSG:';ERROR'
  RETURN
 END
END
*END RCS AFTER DELETE HOOK
ERR=1 ;* NOT REALLY AN ERROR, JUST A FLAG INDICATING THAT MESSAGES ALREADY HAS ITS HEADER
MESSAGES='OK;0;Record deleted;'
RETURN
*
!
*
DO.READNEXT: *
*
*READNEXT,FNAME{,ATTR{,VAL{,SUBVAL{,,,,CLIENT}}}}
*
READNEXT ID ELSE
 ERR=1
 MESSAGES='OK;-1;END OF FILE;ERROR'
 RETURN
END
GOSUB PARSE.READNEXT.CMD
IF IO.FNAME='' THEN
 ERR=1
 MESSAGES='OK;200;File name missing;ERROR'
 RETURN
END
IO.RNAME=ID
IF IO.ATTR=0 THEN
 *JUST WANTS ID
 MESSAGES=ID
 RETURN
END
SKIP.PARSE.IO=1
GOSUB DO.READ
SKIP.PARSE.IO=0
RETURN
*
!
*
DO.EXECUTE: *
*
ERR=1;MESSAGES='OK;1;Generic version of FTSVRSUB does not support EXECUTE function;ERROR';*#GENERIC#*
SAVE.CMD = THE.DATA
THE.DATA = ''
*BEGIN RCS BEFORE EXECUTE HOOK
IF RCS.VER>=3 THEN
 ERRCD=0; ERMSG=''
 CALL @RCS.SUB(11,SAVE.CMD,FIELD(THE.CMD,',',2),THE.DATA,IO.CLIENT,ERRCD,ERMSG) ;* CALL RCS BEFORE EXECUTE
 IF ERRCD=-1 THEN 
  ERRCD=0
  IF FIELD(THE.CMD,',',2) = 0 THEN
   MESSAGES=''; *DISCARD OUTPUT
  END ELSE
   MESSAGES=THE.DATA
  END
  RETURN
 END
 IF ERRCD THEN
  ERR=1 ;* RCS CANCELLED EXECUTE - RETURN ERROR TO CLIENT
  MESSAGES='OK;':ERRCD:';':ERMSG:';ERROR'
  RETURN
 END
END
*END RCS BEFORE EXECUTE HOOK
*CHECK FOR STACKED DATA
CMD=SAVE.CMD
K=INDEX(CMD,AM,1)
IF K THEN
 DATA CMD[K+1,999999999]
 CMD=CMD[1,K-1]
END
*EXECUTE, CAPTURING (SO WE DONT SEND THE ENTIRE OUTPUT TO THE TERMINAL)
ERR=1;MESSAGES='OK;1;Generic version of FTSVRSUB does not support EXECUTE function;ERROR';*#DEFAULT#*
*#ADDS#*EXECUTE CMD CAPTURING MESSAGES
*#AP#*EXECUTE CMD CAPTURING MESSAGES
*#CACHE#*EXECUTE CMD CAPTURING MESSAGES
*#ENH#*EXECUTE CMD CAPTURING MESSAGES
*#JB#*EXECUTE CMD CAPTURING MESSAGES
*#MD#*PERFORM CMD CAPTURING MESSAGES
*#MVBASE#*EXECUTE CMD CAPTURING MESSAGES
*#MVON#*EXECUTE CMD CAPTURING MESSAGES
*#NR#*PERFORM CMD CAPTURING MESSAGES
*#OAS#*EXECUTE CMD CAPTURING MESSAGES
*#OI#*EXECUTE CMD CAPTURING MESSAGES
*#ON#*EXECUTE CMD CAPTURING MESSAGES
*#PICK#*EXECUTE CMD CAPTURING MESSAGES
*#QM#*EXECUTE CMD CAPTURING MESSAGES
*#R83#*EXECUTE CMD CAPTURING MESSAGES
*#SEQ#*EXECUTE CMD CAPTURING MESSAGES
*#UD#*EXECUTE CMD CAPTURING MESSAGES
*#ULT#*EXECUTE CMD CAPTURING MESSAGES
*#ULTX#*EXECUTE CMD, // OUT.>MESSAGES
*#UV#*EXECUTE CMD CAPTURING MESSAGES
*#VIS#*EXECUTE CMD CAPTURING MESSAGES
IF FIELD(THE.CMD,',',2) = 0 THEN
 MESSAGES=''; *DISCARD OUTPUT
END
*BEGIN RCS AFTER EXECUTE HOOK
IF RCS.VER>=3 THEN
 ERRCD=0; ERMSG=''
 CALL @RCS.SUB(12,SAVE.CMD,FIELD(THE.CMD,',',2),MESSAGES,IO.CLIENT,ERRCD,ERMSG) ;* CALL RCS AFTER EXECUTE
 IF ERRCD=-1 THEN ERRCD=0
 IF ERRCD THEN
  ERR=1 ;* RCS CANCELLED EXECUTE - RETURN ERROR TO CLIENT
  MESSAGES='OK;':ERRCD:';':ERMSG:';ERROR'
  RETURN
 END
END
*END RCS AFTER EXECUTE HOOK
RETURN
*
!
*
DO.CALL: *
*
THE.SUB=FIELD(THE.CMD,',',2)
THE.FUNC=FIELD(THE.CMD,',',3)
ERRCD=0; ERMSG=''
*BEGIN RCS BEFORE CALL HOOK
IF RCS.VER>=3 THEN
 CALL @RCS.SUB(13,THE.SUB,THE.FUNC,THE.DATA,IO.CLIENT,ERRCD,ERMSG) ;* CALL RCS BEFORE CALL
 IF ERRCD=-1 THEN
  ERRCD=0
  MESSAGES=THE.DATA ;* HOOK HANDLED THE CALL
  RETURN
 END
 IF ERRCD THEN
  ERR=1 ;* RCS CANCELLED CALL - RETURN ERROR TO CLIENT
  MESSAGES='OK;':ERRCD:';':ERMSG:';ERROR'
  RETURN
 END
END
*END RCS BEFORE CALL HOOK
IF THE.SUB='FTSXT' THEN
 CALL FTSXT(THE.FUNC,THE.DATA,ERRCD,ERMSG,MAT PARAMS,MAT CLIENV,MD)
END ELSE
 CALL @THE.SUB(THE.FUNC,THE.DATA,ERRCD,ERMSG)
END
*BEGIN RCS AFTER CALL HOOK
IF RCS.VER>=3 THEN
 ERRCD=0; ERMSG=''
 CALL @RCS.SUB(14,THE.SUB,THE.FUNC,THE.DATA,IO.CLIENT,ERRCD,ERMSG) ;* CALL RCS AFTER CALL
 IF ERRCD=-1 THEN ERRCD=0
END
*END RCS AFTER CALL HOOK
IF ERRCD THEN
 ERR=1
 MESSAGES='OK;':ERRCD:';':ERMSG:';ERROR'
END ELSE
 MESSAGES=THE.DATA
END
RETURN
*
!
*
DO.CONV: *
*
THE.CODE=THE.DATA<1>
THE.DATA=DELETE(THE.DATA,1)
*BEGIN RCS BEFORE CONV HOOK
IF RCS.VER>=3 THEN
 ERRCD=0; ERMSG=''
 CALL @RCS.SUB(15,OCONV(FIELD(THE.CMD,',',2),'MCU'),THE.CODE,THE.DATA,IO.CLIENT,ERRCD,ERMSG) ;* CALL RCS BEFORE CONV
 IF ERRCD=-1 THEN 
  ERRCD=0
  MESSAGES=THE.DATA ;* HOOK HANDLED THE CONV
  RETURN
 END
 IF ERRCD THEN
  ERR=1 ;* RCS CANCELLED CONV - RETURN ERROR TO CLIENT
  MESSAGES='OK;':ERRCD:';':ERMSG:';ERROR'
  RETURN
 END
END
*END RCS BEFORE CONV HOOK
MESSAGES=''
IF OCONV(FIELD(THE.CMD,',',2),'MCU')='I' THEN 
 MESSAGES=ICONV(THE.DATA,THE.CODE)
END ELSE
 MESSAGES=OCONV(THE.DATA,THE.CODE)
END
*BEGIN RCS AFTER CONV HOOK
IF RCS.VER>=3 THEN
 ERRCD=0; ERMSG=''
 CALL @RCS.SUB(16,OCONV(FIELD(THE.CMD,',',2),'MCU'),THE.CODE,MESSAGES,IO.CLIENT,ERRCD,ERMSG) ;* CALL RCS AFTER CONV
 IF ERRCD=-1 THEN ERRCD=0
 IF ERRCD THEN
  ERR=1 ;* RCS CANCELLED CONV - RETURN ERROR TO CLIENT
  MESSAGES='OK;':ERRCD:';':ERMSG:';ERROR'
  RETURN
 END
END
*END RCS AFTER CONV HOOK
RETURN
*
!
*
DO.RELEASE: *
*
*RELEASE,FNAME,ID{,,,,,,,CLIENT}
*
GOSUB PARSE.IO.CMD
MESSAGES=''
GOSUB INTERNAL.RELEASE
RETURN
*
!
*
DO.FSI: *
*
THE.FUNC=FIELD(THE.CMD,',',2)
SAVE.CMD=THE.DATA
ERRCD=0; ERMSG=''
*BEGIN RCS BEFORE FSI HOOK
IF RCS.VER>=3 THEN
 ERRCD=0; ERMSG=''
 CALL @RCS.SUB(21+((THE.FUNC-1)*2),SAVE.CMD,THE.FUNC+0,THE.DATA,IO.CLIENT,ERRCD,ERMSG) ;* CALL RCS BEFORE FSI
 IF ERRCD=-1 THEN 
  ERRCD=0
  MESSAGES=THE.DATA ;* HOOK HANDLED THE FSI FUNCTION
  RETURN
 END
 IF ERRCD THEN
  ERR=1 ;* RCS CANCELLED FSI FUNCTION - RETURN ERROR TO CLIENT
  MESSAGES='OK;':ERRCD:';':ERMSG:';ERROR'
  RETURN
 END
 THE.DATA=SAVE.CMD
END
*END RCS BEFORE FSI HOOK
CALL FTFSI(THE.FUNC,THE.DATA,ERRCD,ERMSG,MAT PARAMS,MAT CLIENV,FV,MD)
*BEGIN RCS AFTER FSI HOOK
IF RCS.VER>=3 THEN
 ERRCD=0; ERMSG=''
 CALL @RCS.SUB(22+((THE.FUNC-1)*2),SAVE.CMD,THE.FUNC+0,THE.DATA,IO.CLIENT,ERRCD,ERMSG) ;* CALL RCS AFTER FSI
 IF ERRCD=-1 THEN ERRCD=0
END
*END RCS AFTER FSI HOOK
IF ERRCD THEN
 ERR=1
 MESSAGES='OK;':ERRCD:';':ERMSG:';ERROR'
END ELSE
 MESSAGES=THE.DATA
END
RETURN
*
!
*
PARSE.CMD: *
*
ERR=0
IF CMD[1,4]='ERR:' THEN
 KEYWORD='ERR'
 THE.CMD='ERR'
 THE.DATA=TRIM(CMD[5,999999999])
 ULOCK=0
 RETURN
END
*7.1.3: PARSE.CMD UPDATED TO ALLOW SEMICOLONS IN QUOTED FILENAME OR ITEMID FIELDS
*ST.SEMI=INDEX(CMD,';',1)
*IF ST.SEMI=0 THEN
* ST.SEMI=LEN(CMD)+1
*END
CMD.LEN = LEN(CMD)
ST.SEMI=INDEX(CMD,';',1)
ST.QUOT=INDEX(CMD,',"',1)
LOOP WHILE ST.QUOT > 0 AND ST.SEMI > ST.QUOT DO
 * FIND END OF CURRENT QUOTED SEGMENT
 ED.QUOT=INDEX(CMD[ST.QUOT+2,CMD.LEN],'"',1)
 IF ED.QUOT=0 THEN ED.QUOT=CMD.LEN+1 ELSE ED.QUOT=ED.QUOT+ST.QUOT+1
 * FIND BEGINNING OF NEXT QUOTED SEGMENT
 ST.QUOT=INDEX(CMD[ED.QUOT+1,CMD.LEN],',"',1)
 IF ST.QUOT > 0 THEN ST.QUOT=ST.QUOT+ED.QUOT ELSE ST.QUOT=CMD.LEN+1
 IF ST.SEMI > ED.QUOT AND ST.SEMI < ST.QUOT THEN
  * SEMICOLON IS OUTSIDE OF QUOTED SEGMENT - EXIT THE LOOP
  ST.QUOT = 0
 END ELSE
  * LOOK FOR NEXT SEMICOLON AFTER CURRENT QUOTED SEGMENT
  ST.SEMI=INDEX(CMD[ED.QUOT+1,CMD.LEN],';',1)
  IF ST.SEMI > 0 THEN ST.SEMI=ST.SEMI+ED.QUOT
 END
REPEAT
IF ST.SEMI=0 THEN ST.SEMI=CMD.LEN+1
THE.CMD=CMD[1,ST.SEMI-1]
THE.DATA=CMD[ST.SEMI+1,999999999]
KEYWORD=OCONV(TRIM(FIELD(THE.CMD,',',1)),'MCU')
LAST.CHAR=LEN(KEYWORD)
IF KEYWORD[LAST.CHAR,1]='U' THEN
 ULOCK=1
 LAST.CHAR=LAST.CHAR-1
 KEYWORD=KEYWORD[1,LAST.CHAR]
END ELSE ULOCK=0
RETURN
*
!
*
PARSE.IO.CMD: *
*
J=1
FOR I=1 TO 10
 CC=FIELD(THE.CMD,",",J)
 IF (I=2 OR I=3) AND CC[1,1]='"' THEN
  CC=THE.CMD[COL1()+1,999]
  K=INDEX(CC,'"',2)
  IF K=0 THEN K=LEN(CC)+1
  IO.ARRAY(I)=TRIM(CC[2,K-2])
  J=J+COUNT(IO.ARRAY(I),',')
 END ELSE
  IO.ARRAY(I)=TRIM(CC)
 END
 J=J+1
NEXT I
*
RETURN
!
*
PARSE.READNEXT.CMD: *
*
MAT IO.ARRAY=''
J=1
FOR I=1 TO 9
 CC=FIELD(THE.CMD,",",J)
 IF I=2 AND CC[1,1]='"' THEN
  CC=THE.CMD[COL1()+1,999]
  K=INDEX(CC,'"',2)
  IF K=0 THEN K=LEN(CC)+1
  IO.ARRAY(I)=TRIM(CC[2,K-2])
  J=J+COUNT(IO.ARRAY(I),',')
 END ELSE
  IF I>2 THEN GG2=I+1 ELSE GG2=I
  IO.ARRAY(GG2)=TRIM(CC)
 END
 J=J+1
NEXT I
RETURN
*
!
*
OPEN.FILE: *
*
IF IO.FNAME EQ '' THEN
 ERR=1
 MESSAGES="OK;201;Unable to open '';ERROR"
 RETURN
END
ERR=0
LOCATE(IO.FNAME,OPEN.FILES(1);Var) THEN
 FLV=OPEN.FILES(Var+1)
END ELSE
 USE.DICT=''
 IF FIELD(IO.FNAME,' ',1)='DICT' THEN
  USE.DICT='DICT'
  USE.FNAME=FIELD(IO.FNAME,' ',2)
 END ELSE
  USE.FNAME=IO.FNAME
 END
 OPEN USE.DICT,USE.FNAME TO FLV ELSE
  ERR=1
  MESSAGES="OK;201;Unable to open ":IO.FNAME:';ERROR'
  RETURN
 END
 IF Var < 200 THEN
  OPEN.FILES(1)<-1> = IO.FNAME
  OPEN.FILES(Var+1) = FLV
 END
END
RETURN
!
INTERNAL.LOCK: *
*
*NOTE: DO.READ HANDLES SETUP (PARSE, OPEN, ETC.)
*
SAVE.FNAME=IO.FNAME
SAVE.RNAME=IO.RNAME
TMP.FNAME=IO.FNAME
TMP.RNAME=IO.RNAME
*BEGIN RCS BEFORE LOCK HOOK
IF RCS.VER>=2 THEN   
 ERRCD=0; ERMSG=''
 CALL @RCS.SUB(5,TMP.FNAME,TMP.RNAME,'',IO.CLIENT,ERRCD,ERMSG) ;* CALL RCS BEFORE LOCKING RECORD
 IF ERRCD=-1 THEN
  * RCS LOCKED THE RECORD
  RETURN
 END
 IF ERRCD THEN
  ERR=1 ;* RCS CANCELLED LOCK - RETURN ERROR TO CLIENT
  MESSAGES='OK;':ERRCD:';':ERMSG:';ERROR'
  RETURN
 END
END
*END RCS BEFORE LOCK HOOK
GOSUB TEST.LOCAL.LOCK
IF LOCAL.LOCKED THEN
 ERR=1
 MESSAGES='OK;260;Unable to read locked record ':IO.FNAME:' ':IO.RNAME:';ERROR'
 RETURN
END
* UPDATE FILE NAME / ITEM ID IN CASE RCS CHANGED
IO.FNAME=TMP.FNAME
IO.RNAME=TMP.RNAME
GOSUB OPEN.FILE
IO.FNAME=SAVE.FNAME
IO.RNAME=SAVE.RNAME
IF ERR THEN RETURN
* TRY TO SET THE RECORD LOCK
READU WORK FROM FLV,TMP.RNAME LOCKED
 ERR=1
 MESSAGES='OK;260;Unable to read locked record ':TMP.FNAME:' ':TMP.RNAME:';ERROR'
 RETURN
END ELSE
END
WORK=''
*BEGIN RCS AFTER LOCK HOOK
IF RCS.VER>=2 THEN   
 ERRCD=0; ERMSG=''
 CALL @RCS.SUB(10,TMP.FNAME,(TMP.RNAME),'',IO.CLIENT,ERRCD,ERMSG) ;* CALL RCS AFTER LOCKING RECORD
 IF ERRCD=-1 THEN ERRCD=0
 IF ERRCD THEN
  * IF RCS FAILS THE LOCK, RELEASE THE READU LOCK
  RELEASE FLV,TMP.RNAME
  ERR=1 ;* RCS CANCELLED LOCK - RETURN ERROR TO CLIENT
  MESSAGES='OK;':ERRCD:';':ERMSG:';ERROR'
  RETURN
 END
END
*END RCS BEFORE LOCK HOOK
GOSUB SET.LOCAL.LOCK
RETURN
*
!
*
INTERNAL.RELEASE: *
*
*NOTE: DO.RELEASE HANDLES SETUP (PARSE, OPEN, ETC.)
*
SAVE.FNAME=IO.FNAME
SAVE.RNAME=IO.RNAME
TMP.FNAME=IO.FNAME
TMP.RNAME=IO.RNAME
*BEGIN RCS BEFORE UNLOCK HOOK
IF RCS.VER THEN
 ERRCD=0; ERMSG=''
 CALL @RCS.SUB(4,TMP.FNAME,TMP.RNAME,'',IO.CLIENT,ERRCD,ERMSG) ;* CALL RCS BEFORE UNLOCKING RECORD
 IF ERRCD=-1 THEN
  * RCS UNLOCKED THE RECORD
  RETURN
 END
 IF ERRCD THEN
  ERR=1 ;* RCS CANCELLED UNLOCK - RETURN ERROR TO CLIENT
  MESSAGES='OK;':ERRCD:';':ERMSG:';ERROR'
  RETURN
 END
 * UPDATE FILE NAME / ITEM ID IN CASE RCS CHANGED
 IO.FNAME=TMP.FNAME
 IO.RNAME=TMP.RNAME
END
*END RCS BEFORE UNLOCK HOOK
IF IO.FNAME='' THEN
 RELEASE ;* RELEASE ALL ITEM LOCKS
 LOCAL.LOCK.TABLE='' ;* CLEAR LOCAL LOCK TABLE
END ELSE
 GOSUB OPEN.FILE
 IF ERR THEN
  IO.FNAME=SAVE.FNAME
  IO.RNAME=SAVE.RNAME
  RETURN
 END
 RELEASE FLV,IO.RNAME ;* RELEASE ITEM LOCK
 IO.FNAME=SAVE.FNAME
 IO.RNAME=SAVE.RNAME
 GOSUB CLEAR.LOCAL.LOCK
END
*BEGIN RCS AFTER UNLOCK HOOK
IF RCS.VER>=2 THEN
 ERRCD=0; ERMSG=''
 CALL @RCS.SUB(9,TMP.FNAME,TMP.RNAME,'',IO.CLIENT,ERRCD,ERMSG) ;* CALL RCS BEFORE UNLOCKING RECORD
 IF ERRCD=-1 THEN ERRCD=0
 IF ERRCD THEN
  ERR=1 ;* RCS CANCELLED UNLOCK - RETURN ERROR TO CLIENT
  MESSAGES='OK;':ERRCD:';':ERMSG:';ERROR'
  RETURN
 END
END
*END RCS AFTER UNLOCK HOOK
RETURN
*
!
*
SET.LOCAL.LOCK: *
*
IF STRICT.LOCKING THEN
 LOCAL.LOCK.ID=IO.FNAME:'*':IO.RNAME
 LOCATE(LOCAL.LOCK.ID,LOCAL.LOCK.TABLE;Var) THEN
  NULL
 END ELSE
  LOCAL.LOCK.TABLE<-1> = LOCAL.LOCK.ID
 END
END
RETURN
!
*
CLEAR.LOCAL.LOCK: *
*
IF STRICT.LOCKING THEN
 LOCAL.LOCK.ID=IO.FNAME:'*':IO.RNAME
 LOCATE(LOCAL.LOCK.ID,LOCAL.LOCK.TABLE;Var) THEN
  LOCAL.LOCK.TABLE=DELETE(LOCAL.LOCK.TABLE,Var)
 END
END
RETURN
!
*
TEST.LOCAL.LOCK: *
*
IF STRICT.LOCKING THEN
 LOCAL.LOCK.ID=IO.FNAME:'*':IO.RNAME
 LOCATE(LOCAL.LOCK.ID,LOCAL.LOCK.TABLE;Var) THEN
  LOCAL.LOCKED=1
 END ELSE
  LOCAL.LOCKED=0
 END
END ELSE
 LOCAL.LOCKED=0
END
RETURN
!
*
END
