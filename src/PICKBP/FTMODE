SUBROUTINE FTMODE(STAT,SUBNAME,MAT PARAMS,MAT VARS,MAT CLIENV)
**************************************************************************
*Copyright (c) 1993-2012 Zumasys,Inc. as an unpublished work. All rights *
*reserved. This work is the property of and embodies trade secrets and   *
*confidential information proprietary to Zumasys, Inc.  It may not be    *
*reproduced, copied, used, disclosed, transferred, adapted or modified   *
*without the express written approval of Zumasys, Inc., except as        *
*provided for in the accompanying warranty notice and licensing          *
*agreement.                                                              *
**************************************************************************
*
* MODULE: FTMODE
* AUTHOR: PJS
* VERSION: 7.1.1
* CREATED: 01/01/1993
* UPDATED: 03/17/2012
*
* MAINTENANCE RECORD:
*
* 7.1.1
*  PJS 03/17/2012
*   Added support for character set translation to be handled by the
*   ASCII or Kermit protocol, rather than as an extra step calling
*   the file converter.
*
* 5.4.1
*  PJS 04/18/2007
*   Added support for extended delimiters. Check response from converter
*   'FT' command to determine if extended delimiters are supported.
*
* 5.3.1
*  PJS 07/24/2006
*   Changed size of VARS() array from 25 to 26.
*
* 5.1.4
*  PJS 09/29/2003
*   Send delimiter flag to converter in FT/UL/DL functions, since
*   intermediate files always have TAB delimiter (fixes append text
*   files with comma delimiter bug).
*
* 5.1.3
*  PJS 09/11/2003
*   Modified PRINT expressions for UniVerse because concatenated
*   expressions are sent in separate packets in NT version of
*   UniVerse causing TCP "delayed ack" performance issues.
*
* 5.1.2
*  PJS 11/25/2002
*   Added extra arguments to 'FT' function in converter to allow enable
*   support for appending to text files using FTD.
*
* 5.1.1
*  PJS 09/15/2002
*   Added support for column names in converter. Added CLST to VARS()
*   array as VARS(15).
*
* 5.0.1
*  PJS 02/17/2002
*   Added new element to CLIENV() array for FTBP library version number.
*
* 4.0.2
*  PJS 01/03/2001
*   Check for services (CLI.SVCS) using lower case instead of upper
*   case to support systems which are case sensitive.
*
* 4.0.1
*  PJS 09/25/2000
*   CLEANUP FOR ACCUTERM 2000 RELEASE
*   NEW ARGUMENT: MAT CLIENV CONTAINS INFORMATION ABOUT ACCUTERM
*   MAJOR RE-WRITE TO ENABLE FILE CHARACTER SET CONVERSIONS
*   ALL FILE CONVERSION (CHARACTER SET, FILE FORMAT) LOGIC MOVED HERE
*   CLEANED UP ERROR REPORTING FOR PARTIALY SUCCESSFUL TRANSFERS
*    (SOME FILE DO NOT EXIST OR SOME FILES CANNOT BE OVRWRITTEN)
*   MOVE ASCII FILE UPLOAD LIST GENERATION TO FTFILIST (LIST IS
*    ALSO USED BY KERMIT WHEN FILE CONVERSION IS REQUIRED)
*
**************************************************************************
**************************************************************************
*
* ACCUTERM FILE TRANSFER - REMOTE COMMAND
*
**************************************************************************
**************************************************************************
*
DIM PARAMS(30), VARS(26), CLIENV(10)
*
EQU TXT.FLG.PARAM TO PARAMS(13)
EQU EXT.FLG.PARAM TO PARAMS(14)
EQU OVR.FLG.PARAM TO PARAMS(15)
EQU DCH.FLG.PARAM TO PARAMS(18)
EQU DIR.FLG.PARAM TO PARAMS(21)
EQU FIL.FLG.PARAM TO PARAMS(22)
EQU FIL.CNV.PARAM TO PARAMS(23)
EQU OEM.CHR.PARAM TO PARAMS(24)
EQU PRO.FLG.PARAM TO PARAMS(25)
*
EQU ICNT TO VARS(1)
EQU BCNT TO VARS(2)
EQU IDMODE TO VARS(3)
EQU ALST TO VARS(4)
EQU HDR TO VARS(5)
EQU EXP TO VARS(6)
EQU GEN TO VARS(7)
EQU PFX TO VARS(8)
EQU SID TO VARS(9)
EQU SKP TO VARS(10)
EQU FILE TO VARS(11)
EQU FNAME TO VARS(12)
EQU ID TO VARS(13)
EQU IDLST TO VARS(14)
EQU CLST TO VARS(15)
EQU IDS TO VARS(16)
EQU ISIZ TO VARS(17)
EQU ISEQ TO VARS(18)
EQU ITEM TO VARS(19)
EQU XSIZ TO VARS(20)
EQU PATH TO VARS(21)
EQU FN TO VARS(22)
EQU FNLST TO VARS(23)
EQU DFILE TO VARS(24)
EQU FNS TO VARS(25)
EQU MD TO VARS(26)
*
EQU CLI.PLATFORM TO CLIENV(1)
EQU CLI.PRODUCT TO CLIENV(2)
EQU CLI.RELEASE TO CLIENV(3)
EQU CLI.CAPAS TO CLIENV(4)
EQU CLI.SVCS TO CLIENV(5)
EQU CLI.SERIAL TO CLIENV(6)
EQU CLI.LICENSE TO CLIENV(7)
EQU CLI.USER TO CLIENV(8)
EQU CLI.VERSION TO CLIENV(9)
EQU CLI.CONFIG TO CLIENV(10)
*
**************************************************************************
*
EQU AM TO CHAR(254), VM TO CHAR(253)
EQU CR TO CHAR(13), ESC TO CHAR(27), STX TO CHAR(2), SUB TO CHAR(26)
EQU EM TO CHAR(25)
*
**************************************************************************
*
* CHECK PATH
*
**************************************************************************
*
X=PATH[LEN(PATH),1]
IF X NE '' AND X NE ':' AND X NE '\' THEN PATH=PATH:'\'
*
**************************************************************************
*
* CHARACTER SET CONVERSION OPTIONS (UTF-8 SUPPORT)
*
IF OEM.CHR.PARAM AND TXT.FLG.PARAM THEN
 IF INDEX(CLI.CAPAS,'F',1) THEN
  * PROTOCOL SUPPORTS ON-THE-FLY CHARSET CONVERSION
  XTRNL.OEM.CHR = 0
  XLATE.CHRSET = 1
 END ELSE
  * OLDER VERSIONS DO NOT SUPPORT ON-THE-FLY CONVERSION
  XTRNL.OEM.CHR = 1
  XLATE.CHRSET = 0
 END
END ELSE
 * NO CHARSET CONVERSION REQUIRED
 XTRNL.OEM.CHR = 0
 XLATE.CHRSET = 0
END
*
**************************************************************************
*
* EXECUTE PROPER TRANSFER PROTOCOL
*
**************************************************************************
*
STAT=''
WARN=''
FATAL=0
EOF=0; * 0=MORE DATA, 1=EOF THIS ITEM/FILE, 2=EOF ENTIRE TRANSACTION
CAN=0; * 0=READY, 1=CANCEL THIS ITEM/FILE, 2=CANCEL ENTIRE TRANSACTION
*
BEGIN CASE
*
**************************************************************************
*
* KERMIT SEND
*
**************************************************************************
*
 CASE PRO.FLG.PARAM AND DIR.FLG.PARAM
  * PRIME THE DATA PUMP
  CALL @SUBNAME('',0,0,EOF,CAN,STAT,MAT PARAMS,MAT VARS)
  IF STAT NE '' THEN RETURN; * MUST BE A FATAL ERROR
  IF EOF>1 THEN STAT='No data to send!'; RETURN
  *
  * SELECT BATCH OR SINGLE-FILE MODE
  *
  IF NOT(TXT.FLG.PARAM AND (FIL.CNV.PARAM OR XTRNL.OEM.CHR) AND (INDEX(CLI.SVCS,'b',1)>0)) THEN
   *
   * LET DATA SOURCE DRIVE THE PROTOCOL IN BATCH MODE
   *
   PRINT '':(ESC:STX:'DK':('NO'[1+OVR.FLG.PARAM,1]):('BT'[1+TXT.FLG.PARAM,1]):('C'[1,XLATE.CHRSET]):';':PATH:CR):
   CALL FTKERMIT(STAT,SUBNAME,0,MAT PARAMS,MAT VARS); * DOWNLOAD BATCH OF FILES
   *
  END ELSE
   *
   * PROCESS FILE-BY-FILE SO WE CAN DO CHARACTER SET & FILE FORMAT CONVERSION
   *
   LOOP
    CAN=0; * INIT FOR NEXT FILE
    CALL @SUBNAME('',0,0,EOF,CAN,STAT,MAT PARAMS,MAT VARS); * ANY DATA TO SEND?
   UNTIL EOF > 1 OR FATAL DO
    IF NOT(EOF) THEN
     GOSUB 400; * GET TEMP FILE NAME BEFORE DOWNLOAD
     IF INDEX(OCONV(STAT,'MCU'),'EXIST',1) THEN
      WARN='Destination file exists!'
      STAT=''
      FATAL=0
      CAN=1
      CALL @SUBNAME('',0,0,EOF,CAN,STAT,MAT PARAMS,MAT VARS); * CANCEL CURRENT FILE
     END ELSE
      PRINT '':(ESC:STX:'DK':('NO'[1+OVR.FLG.PARAM,1]):('BT'[1+TXT.FLG.PARAM,1]):('C'[1,XLATE.CHRSET]):';':PATH:CR):
      * DOWNLOAD TO TEMP FILE
      CALL FTKERMIT(STAT,SUBNAME,1,MAT PARAMS,MAT VARS); * DOWNLOAD ONE FILE
      IF STAT EQ '' THEN
       CALL FTSTATUS(STAT,FATAL,MAT PARAMS,MAT VARS,MAT CLIENV); * CHECK STATUS
      END ELSE
       FATAL=1
      END
     END
     IF FATAL THEN
      CAN=2
      CALL @SUBNAME('',0,0,EOF,CAN,'',MAT PARAMS,MAT VARS)
     END
     GOSUB 500; * CONVERT FILE TO TARGET FORMAT & DELETE TEMPORARY FILE
    END
   REPEAT
   *
  END
  IF STAT EQ '' THEN STAT = WARN
*
*
**************************************************************************
*
* KERMIT RECEIVE
*
**************************************************************************
*
 CASE PRO.FLG.PARAM AND NOT(DIR.FLG.PARAM)
  *
  XICNT=0; XBCNT=0
  *
  * SELECT BATCH OR SINGLE-FILE MODE
  *
  IF NOT(TXT.FLG.PARAM AND (FIL.CNV.PARAM OR XTRNL.OEM.CHR) AND (INDEX(CLI.SVCS,'b',1)>0)) THEN
   *
   * BATCH MODE
   *
   LOOP WHILE FNLST NE '' AND STAT EQ '' DO
    ICNT=0; BCNT=0
    FN=FNLST<1>
    FNLST=DELETE(FNLST,1,0,0)
    PRINT '':(ESC:STX:'UK':('BT'[1+TXT.FLG.PARAM,1]):('C'[1,XLATE.CHRSET]):';':PATH:FN:CR):; * INITIATE REMOTE UPLOAD
    CALL FTKERMIT(STAT,SUBNAME,0,MAT PARAMS,MAT VARS)
    IF STAT EQ '' THEN
     CALL FTSTATUS(STAT,FATAL,MAT PARAMS,MAT VARS,MAT CLIENV)
    END ELSE
     FATAL=1
    END
    IF STAT NE '' THEN
     IF FATAL THEN
      IF OCONV(STAT,'MCU')[1,17] EQ 'FILE NOT FOUND - ' THEN
       IF WARN EQ '' THEN WARN=STAT ELSE WARN=WARN:', ':STAT[18,999]
       FATAL=0; STAT=''
      END ELSE
       IF INDEX(OCONV(STAT,'MCU'),'EXIST',1) THEN
        IF WARN EQ '' THEN WARN = STAT
        FATAL=0; STAT=''
       END
      END
     END
    END
    XICNT=XICNT+ICNT; XBCNT=XBCNT+BCNT
   REPEAT
   *
  END ELSE
   *
   * SINGLE FILE MODE
   *
   CALL FTFILIST(STAT,PATH,FNLST,MAT PARAMS,MAT CLIENV)
   LOOP WHILE FNLST NE '' AND STAT EQ '' DO
    ICNT = 0; BCNT = 0
    FN=FNLST<1>
    FNLST=DELETE(FNLST,1,0,0)
    GOSUB 600; * DO FILE FORMAT & CHARACTER SET CONVERSION BEFORE UPLOAD
    IF STAT EQ '' THEN
     PRINT '':(ESC:STX:'UK':('BT'[1+TXT.FLG.PARAM,1]):('C'[1,XLATE.CHRSET]):';':PATH:FN:CR):; * INITIATE REMOTE UPLOAD
     CALL FTKERMIT(STAT,SUBNAME,0,MAT PARAMS,MAT VARS)
    END
    IF STAT EQ '' THEN
     CALL FTSTATUS(STAT,FATAL,MAT PARAMS,MAT VARS,MAT CLIENV)
    END ELSE
     FATAL=1
    END
    IF STAT NE '' THEN
     IF FATAL AND (OCONV(STAT,'MCU')[1,17] EQ 'FILE NOT FOUND - ') THEN
      IF WARN EQ '' THEN WARN=STAT ELSE WARN=WARN:', ':STAT[18,999]
       FATAL=0; STAT=''
      END
    END
    IF FATAL THEN CALL @SUBNAME('',0,0,2,2,'',MAT PARAMS,MAT VARS)
    XICNT=XICNT+ICNT; XBCNT=XBCNT+BCNT
    GOSUB 700; * DELETE TEMPORARY FILE
   REPEAT
   *
  END
  IF STAT EQ '' THEN STAT=WARN
  ICNT=XICNT; BCNT=XBCNT
*
**************************************************************************
*
* ASCII SEND
*
**************************************************************************
*
 CASE NOT(PRO.FLG.PARAM) AND DIR.FLG.PARAM
  * PRIME THE DATA PUMP
  CALL @SUBNAME('',0,0,EOF,CAN,STAT,MAT PARAMS,MAT VARS)
  IF STAT NE '' THEN RETURN
  IF EOF>1 THEN STAT='No data to send!'; RETURN
  LOOP
   CAN=0; * INIT FOR NEXT FILE
   CALL @SUBNAME('',0,0,EOF,CAN,STAT,MAT PARAMS,MAT VARS)
  UNTIL EOF > 1 OR FATAL DO
   IF NOT(EOF) THEN
    GOSUB 400; * GET TEMP FILE NAME BEFORE DOWNLOAD
    IF INDEX(OCONV(STAT,'MCU'),'EXIST',1) THEN
     WARN='Destination file exists!'
     STAT=''
     FATAL=0
     CAN=1
     CALL @SUBNAME('',0,0,EOF,CAN,STAT,MAT PARAMS,MAT VARS); * CANCEL CURRENT FILE
    END ELSE
     PRINT '':(ESC:STX:'DA':('NO'[1+OVR.FLG.PARAM,1]):'T':('C'[1,XLATE.CHRSET]):';':PATH:FN:CR):
     * DOWNLOAD TO DESTINATION OR TEMP FILE
     CALL FTASCII(STAT,SUBNAME,1,MAT PARAMS,MAT VARS)
     IF STAT EQ '' THEN
      CALL FTSTATUS(STAT,FATAL,MAT PARAMS,MAT VARS,MAT CLIENV)
     END ELSE
      FATAL=1
     END
    END
    IF FATAL THEN
     CAN=2
     CALL @SUBNAME('',0,0,EOF,CAN,'',MAT PARAMS,MAT VARS)
    END
    GOSUB 500; * CONVERT FILE TO TARGET FORMAT
   END
  REPEAT
  IF STAT EQ '' THEN STAT=WARN
*
**************************************************************************
*
* ASCII RECEIVE
*
**************************************************************************
*
 CASE NOT(PRO.FLG.PARAM) AND NOT(DIR.FLG.PARAM)
  CALL FTFILIST(STAT,PATH,FNLST,MAT PARAMS,MAT CLIENV)
  XICNT=0; XBCNT=0
  LOOP WHILE FNLST NE '' AND STAT EQ '' DO
   ICNT=0; BCNT=0
   FN=FNLST<1>
   FNLST=DELETE(FNLST,1,0,0)
   GOSUB 600; * DO FILE FORMAT & CHARACTER SET CONVERSION BEFORE UPLOAD
   IF STAT EQ '' THEN
    PRINT '':(ESC:STX:'UAT':('C'[1,XLATE.CHRSET]):';':PATH:FN:CR):; * INITIATE REMOTE UPLOAD
    CALL FTASCII(STAT,SUBNAME,1,MAT PARAMS,MAT VARS)
   END
   IF STAT EQ '' THEN
    SLEEP 1; * LET SENDER FLUSH RECEIVE BUFFER BEFORE ISSUING STATUS COMMAND
    CALL FTSTATUS(STAT,FATAL,MAT PARAMS,MAT VARS,MAT CLIENV)
   END ELSE
    FATAL=1
   END
   IF STAT NE '' THEN
    IF FATAL AND (OCONV(STAT,'MCU')[1,17] EQ 'FILE NOT FOUND - ') THEN
     IF WARN EQ '' THEN WARN=STAT ELSE WARN=WARN:', ':STAT[18,999]
     FATAL = 0; STAT = ''
    END
   END ELSE
    IF STAT EQ '' THEN
     IF BCNT EQ 0 THEN
      * WRITE EMPTY ITEM SINCE IT REALLY DOES EXIST
      CALL @SUBNAME('',0,0,1,CAN,STAT,MAT PARAMS,MAT VARS); * FLUSH ITEM
      IF STAT NE '' THEN FATAL=1
     END
    END
   END
   IF FATAL THEN CALL @SUBNAME('',0,0,2,2,'',MAT PARAMS,MAT VARS)
   XICNT= XICNT+ICNT; XBCNT=XBCNT+BCNT
   GOSUB 700; * DELETE TEMPORARY FILE
  REPEAT
  IF STAT EQ '' THEN STAT=WARN
  ICNT=XICNT; BCNT=XBCNT
END CASE
*
*
IF STAT NE '' THEN RETURN
*
* GET FILE TRANSFER STATUS
*
CALL FTSTATUS(STAT,FATAL,MAT PARAMS,MAT VARS,MAT CLIENV)
*
RETURN
*
*
**************************************************************************
*
* CHECK IF FILE EXISTS
*
**************************************************************************
*
300 *
*
IF OVR.FLG.PARAM THEN RETURN
IF INDEX(CLI.CAPAS,'S',1) EQ 0 THEN RETURN
XST=0
SCR='On Error Resume Next'
SCR=SCR:EM:'X = 0'
SCR=SCR:EM:'X = Abs(FileExists("':PATH:FN:'"))'
SCR=SCR:EM:'InitSession.Output Cstr(X) & Chr$(13)'
PRINT '':(ESC:STX:'P':SCR:CR):
ECHO OFF
PROMPT ''
INPUT XST:
PROMPT '?'
ECHO ON
IF XST THEN
 STAT="Destination file exists!"
 FATAL=1
END
SLEEP 1; * TIMING BUG?
RETURN
*
*
**************************************************************************
*
* PREPARE FOR DOWNLOAD & CONVERSION
*
**************************************************************************
*
400 *
*
* DOES FILE REQUIRE POST-DOWNLOAD FORMAT CONVERSION?
PCNV=0
PFMT=''
PCMD=''
IF TXT.FLG.PARAM = 0 THEN
 GOSUB 300
 RETURN; * ONLY TEXT FILES CAN BE CONVERTED
END
* PARSE COLUMN LIST INTO TMPLST
TMPLST=CLST; LOOP J=INDEX(TMPLST,VM,1) WHILE J DO TMPLST=TMPLST[1,J-1]:'\':TMPLST[J+1,9999] REPEAT
* CHECK IF CONVERSION REQUIRED
IF FIL.CNV.PARAM THEN
 CALL FTOBJREQ('b','FT|':FN:'|':OVR.FLG.PARAM:'|':HDR:'||':TMPLST:'|':DCH.FLG.PARAM,TMP,1,MAT PARAMS,MAT CLIENV)
 IF TMP NE '' THEN
  IF TMP[1,4] NE 'ERR:' THEN
   IF INDEX(OCONV(TMP,'MCU'),'TEXT',1) THEN
    * CHECK IF EXTENDED DELIMITERS REQUESTED
    IF DCH.FLG.PARAM NE 0 AND DCH.FLG.PARAM NE 1 THEN
     * CHECK IF EXTENDED DELIMITERS SUPPORTED
     IF COUNT(TMP,' ') EQ 0 THEN
      * IF EXTENDED DELIMITERS ARE SUPPORTED BY CONVERTER, TEXT FILE DESCRIPTION HAS MULTIPLE WORDS!
      STAT="Only TAB and COMMA delimiters are supported by this version of AccuTerm!"
      FATAL=1
      RETURN
     END
    END
   END
   * CONVERSION IS REQUIRED
   PCNV = 1
   PFMT = TMP
   PCMD = 'DL'
  END
 END
END
* DOES FILE REQUIRE POST-DOWNLOAD CHARACTER SET CONVERSION?
IF XTRNL.OEM.CHR THEN
 CSET='OEM'
 IF PCNV EQ 0 THEN
  PCNV=1
  PFMT='ANSI'
  PCMD='DLX'
 END
END ELSE
 IF XLATE.CHRSET THEN
  CSET='AUTO'
 END ELSE
  CSET='ANSI'
 END
END
IF PCNV EQ 0 THEN
 GOSUB 300; * CHECK IF OK TO OVERWRITE
 RETURN
END
* PRESERVE VALUES
SAVE.OVR.FLG=OVR.FLG.PARAM
SAVE.DCH.FLG=DCH.FLG.PARAM
SAVE.PATH=PATH
SAVE.FN=FN
* GET TEMP FILE NAME FOR DOWNLOAD
CALL FTOBJREQ('b',PCMD:'|':PATH:FN:'|':OVR.FLG.PARAM:'|':HDR:'|':CSET:'|':TMPLST:'|':DCH.FLG.PARAM,TMP,1,MAT PARAMS,MAT CLIENV)
* IS CONVERTER READY?
IF TMP[1,4] EQ 'ERR:' THEN
 PCNV=0; * ERROR - NO CONVERSION POSSIBLE
 IF TMP[1,7] EQ 'ERR: 2 ' THEN 
  GOSUB 300; * CHECK IF OK TO OVERWRITE
  RETURN; * FILE NOT CONVERTABLE
 END
 IF INDEX(OCONV(TMP,'MCU'),'UNKNOWN FUNCTION',1) THEN RETURN; * CONVERSION NOT AVAILABLE
 * EXTRACT ERROR MESSAGE & RETURN FATAL STATUS
 J=INDEX(TMP,' ',2)
 TMP=TMP[J+1,9999]
 IF OCONV(TMP[1,7],'MCU') EQ 'ERROR: ' THEN J=7 ELSE J=0
 STAT=TMP[J+1,9999]
 FATAL=1
 RETURN
END
* EXTRACT TEMP FILE NAME & PATH
TMPFILE=TMP
J=1;L=0;LOOP K=INDEX(TMPFILE,'\',J) WHILE K DO L=K; J=J+1 REPEAT
PATH=TMPFILE[1,L]; * DOWNLOAD TO TEMP PATH
FN=TMPFILE[L+1,9999]; * DOWNLOAD TO TEMP FILE
* ADJUST PARAMS FOR TEMP FILE DOWNLOAD
OVR.FLG.PARAM=1; * OK TO OVERWRITE TEMP FILE
IF PFMT NE 'ANSI' THEN DCH.FLG.PARAM=0; * ALWAYS USE TAB WITH FILE FORMAT CONVERSION
RETURN
*
**************************************************************************
*
* CONVERT FILE AFTER DOWNLOAD
*
**************************************************************************
*
500 *
*
* DOES FILE REQUIRE POST-DOWNLOAD CONVERSION?
IF PCNV EQ 0 THEN RETURN
* DOES FILE REQUIRE PRE/POST CONVERSION?
IF PFMT EQ 'ANSI' THEN
 PRINT 'Converting ':SAVE.FN:' to ANSI character set...':
END ELSE
 PRINT 'Converting ':SAVE.FN:' to ':PFMT:' file format...':
END
TMP=TMPFILE
CALL FTOBJREQ('b','EJ',TMP,1,MAT PARAMS,MAT CLIENV)
PRINT ' done.'
IF STAT EQ '' THEN
 IF TMP NE '' THEN
  IF TMP[1,4] EQ 'ERR:' THEN
   J=INDEX(TMP,' ',2)
   TMP=TMP[J+1,9999]
  END
  IF OCONV(TMP[1,7],'MCU') EQ 'ERROR: ' THEN J=7 ELSE J=0
  STAT=TMP[J+1,9999]
 END
END
* RESTORE VALUES
OVR.FLG.PARAM=SAVE.OVR.FLG
DCH.FLG.PARAM=SAVE.DCH.FLG
PATH=SAVE.PATH
FN=SAVE.FN
RETURN
*
**************************************************************************
*
* CONVERT FILE BEFORE UPLOAD
*
**************************************************************************
*
600 *
*
* DOES FILE REQUIRE PRE-UPLOAD CONVERSION?
PCNV=0
PFMT=''
PCMD=''
IF TXT.FLG.PARAM EQ 0 THEN RETURN; * ONLY TEXT FILES CAN BE CONVERTED
* PARSE COLUMN LIST INTO TMPLST
TMPLST=CLST; LOOP J=INDEX(TMPLST,VM,1) WHILE J DO TMPLST=TMPLST[1,J-1]:'\':TMPLST[J+1,9999] REPEAT
* CHECK IF CONVERSION REQUIRED
IF FIL.CNV.PARAM THEN
 CALL FTOBJREQ('b','FT|':FN:'|':OVR.FLG.PARAM:'|':HDR:'||':TMPLST:'|':DCH.FLG.PARAM,TMP,1,MAT PARAMS,MAT CLIENV)
 IF TMP NE '' THEN
  IF TMP[1,4] NE 'ERR:' THEN
   IF INDEX(OCONV(TMP,'MCU'),'TEXT',1) THEN
    * CHECK IF EXTENDED DELIMITERS REQUESTED
    IF DCH.FLG.PARAM NE 0 AND DCH.FLG.PARAM NE 1 THEN
     * CHECK IF EXTENDED DELIMITERS SUPPORTED
     IF COUNT(TMP,' ') EQ 0 THEN
      * IF EXTENDED DELIMITERS ARE SUPPORTED BY CONVERTED, TEXT FILE DESCRIPTION HAS MULTIPLE WORDS!
      STAT="Only TAB and COMMA delimiters are supported by this version of AccuTerm!"
      FATAL=1
      RETURN
     END
    END
   END
   * CONVERSION IS REQUIRED
   PCNV=1
   PFMT=TMP
   PCMD='UL'
  END
 END
END
* DOES FILE REQUIRE PRE-UPLOAD CHARACTER SET CONVERSION?
IF XTRNL.OEM.CHR THEN
 CSET='OEM'
 IF PCNV EQ 0 THEN
  PCNV=1
  PFMT='ANSI'
  PCMD='ULX'
 END
END ELSE
 IF XLATE.CHRSET THEN
  CSET='UCS2'
 END ELSE
  CSET='ANSI'
 END
END
IF PCNV EQ 0 THEN RETURN
* PRESERVE VALUES
SAVE.DCH.FLG=DCH.FLG.PARAM
SAVE.PATH=PATH
SAVE.FN=FN
IF PFMT EQ 'ANSI' THEN
 PRINT 'Converting ':FN:' to host character set...':
END ELSE
 PRINT 'Converting ':FN:' from ':PFMT:' format for upload...':
END
* CONVERT TO TEMP FILE FOR UPLOAD & GET TEMP FILE NAME
CALL FTOBJREQ('b',PCMD:'|':PATH:FN:'|':OVR.FLG.PARAM:'|':HDR:'|':CSET:'|':TMPLST:'|':DCH.FLG.PARAM,TMP,1,MAT PARAMS,MAT CLIENV)
PRINT ' done.'
* IS CONVERTER READY?
IF TMP[1,4] EQ 'ERR:' THEN
 PCNV = 0; * ERROR - NO CONVERSION POSSIBLE
 IF TMP[1,7] EQ 'ERR: 2 ' THEN RETURN; * FILE NOT CONVERTABLE
 IF INDEX(OCONV(TMP,'MCU'),'UNKNOWN FUNCTION',1) THEN RETURN; * CONVERSION NOT AVAILABLE
 IF FIELD(TMP,' ',2) EQ '53' THEN
  * FILE NOT FOUND
  STAT='File not found - ':FN
 END ELSE
  * EXTRACT ERROR MESSAGE & RETURN FATAL STATUS
  J=INDEX(TMP,' ',2)
  TMP=TMP[J+1,9999]
  IF OCONV(TMP[1,7],'MCU') EQ 'ERROR: ' THEN J=7 ELSE J=0
  STAT=TMP[J+1,9999]
 END
 FATAL=1
 RETURN
END
* EXTRACT TEMP FILE NAME & PATH
TMPFILE=TMP
J=1;L=0;LOOP K=INDEX(TMPFILE,'\',J) WHILE K DO L=K; J=J+1 REPEAT
PATH=TMPFILE[1,L]; * DOWNLOAD TO TEMP PATH
FN=TMPFILE[L+1,9999]; * DOWNLOAD TO TEMP FILE
* ADJUST PARAMS FOR TEMP FILE UPLOAD
IF IDLST EQ '' THEN
 IDLST=SAVE.FN
 IF EXT.FLG.PARAM=0 THEN
  * REMOVE FILE EXTENSION
  J=COUNT(SAVE.FN,'.')
  IF J>0 THEN
   J=INDEX(SAVE.FN,'.',J)
   IF J>0 THEN
    IDLST=SAVE.FN[1,J-1]
   END
  END
 END
END
IF PFMT NE 'ANSI' THEN DCH.FLG.PARAM=0; * ALWAYS USE TAB WITH FILE FORMAT CONVERSION
RETURN
*
**************************************************************************
*
* REMOVE TEMP FILE AFTER UPLOAD
*
**************************************************************************
*
700 *
*
* DOES TEMP FILE EXIST?
IF PCNV=0 THEN RETURN
TMP=TMPFILE
CALL FTOBJREQ('b','EJ',TMP,1,MAT PARAMS,MAT CLIENV)
IF STAT EQ '' THEN
 IF TMP NE '' THEN
  IF TMP[1,4] EQ 'ERR:' THEN
   J=INDEX(TMP,' ',2)
   TMP=TMP[J+1,9999]
  END
  IF OCONV(TMP[1,7],'MCU') EQ 'ERROR: ' THEN J=7 ELSE J=0
  STAT=TMP[J+1,9999]
 END
END
* RESTORE VALUES
DCH.FLG.PARAM=SAVE.DCH.FLG
PATH=SAVE.PATH
FN=SAVE.FN
RETURN
*
END
